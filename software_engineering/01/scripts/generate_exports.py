import ast
import re
from pathlib import Path

PROJECT_PATH = "src/swe_hw_1"
INIT_FILE_PREAMBULA = f"# AUTOGENERATED FILE, DO NOT EDIT!\n# GENERATED BY scripts/generate_exports.py\n\n"
PYTEST_PATTERN = re.compile(".*_test.py")

def extract_public_declarations(module_path):
    with open(module_path, 'r') as f:
        tree = ast.parse(f.read())
    
    declarations = []
    for node in tree.body:
        if isinstance(node, ast.Assign):
            for target in node.targets:
                declarations.append(target.id)

        if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)):
            if not node.name.startswith('_'):
                declarations.append(node.name)
    return declarations

def update_init_file(package_dir):
    package_path = Path(package_dir)

    # Call this recursively
    for item in package_path.iterdir():
        if item.is_dir():
            update_init_file(item)
    
    # Process all .py files in the package (except __init__.py)
    module_paths = package_path.glob("*.py")

    # Extract declarations
    all_declarations = []
    declarations_by_module_name = {}
    for module_path in module_paths: 
        # Exclude declarations from old __init__.py
        if module_path.name == "__init__.py":
            continue
        
        # Exclude declarations from testing files
        if PYTEST_PATTERN.fullmatch(module_path.name) != None:
            continue

        declarations = extract_public_declarations(module_path)

        if len(declarations) != 0:
            declarations_by_module_name[module_path.stem] = sorted(set(declarations))
        all_declarations.extend(declarations)

    if len(all_declarations) == 0:
        return

    # Remove duplicates and sort
    all_declarations = sorted(set(all_declarations))

    # Generate __init__.py content
    lines = [INIT_FILE_PREAMBULA]
    
    # Import from modules
    for module_name, declarations in declarations_by_module_name.items():
        lines.append(f"from .{module_name} import {", ".join(declarations)}\n")
    
    # Write __all__ for explicit control
    if all_declarations:
        lines.append(f"\n__all__ = {list(all_declarations)}\n")
    
    # Write the file
    init_file = package_path / "__init__.py"
    with open(init_file, 'w') as f:
        f.writelines(lines)
    
    print(f"Updated declarations of package {package_path}")

# Run on all packages
def update_all_packages(project_root):
    for item in Path(project_root).iterdir():
        if item.is_dir():
            update_init_file(item)

if __name__ == "__main__":
    update_all_packages(PROJECT_PATH)