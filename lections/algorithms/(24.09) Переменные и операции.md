---
created: 2024-09-24T09:32
updated: 2024-09-28T12:38
---
## Новые типы в С99

- `_Bool` - значения 0/1, целый беззнаковый. Лежит в `stdbool.h`. Для объявление используются `true` и `false`.
- `_Complex` - `float/double/long double`. Лежит в `complex.h`. В C11 поддержка комплексных чисел стала необязательной.

Имена, которые начинаются либо с двух подчеркиваний(`__`), либо с подчеркивания и большой буквы (`_[A-Z]`) зарезервированы под системные функции и типы.

Однако, в С23 `true, false, bool` стали ключевыми словами.

---
## Переменные

- Переменная = $\langle$тип, имя, значение$\rangle$
- Все переменные являеются частью программы
- Объявление переменной: `type name = value`

```c
int a, b; unsigned c = 12345;
```

### Область видимость переменных

Переменная может быть объявлена:
1. Вне функций (глобальная)
2. В объявлении функции (параметр)
3. Внутри функции (локальная)

Область видимости локальной переменной - блок, в котором она объявлена.
Область видимости глобальной переменной - файл, в котором она объявлена.

```c
#include <stdio.h>

int count; // global 
void func (void){
	int count; // local
	count = count - 2;
}

static int mult = 0; // static 
int sum (int x, int y) { 
	count++; 
	return (x + y) * (++mult); 
}

int main (void) {
	register int s = 0; // register 
	count = 0; s += sum (5, 7); 
	func (); 
	printf ("Sum is %d, func is called %d times\n", s, count);
	return 0; 
}


```

`static`, `register` и `auto` - ключевые слова, которые влияют на класс памяти переменных.

Значения статических переменных сохраняется между запусками функции, в которой она объявлена. (Глобальные переменные всегда имеют статический класс памяти.)

Регистровые переменные компилятор старается хранить в регистрах процессора.

Автоматические переменные инициализируются каждый раз, при переходе в их блок.

### Инициализация переменных

```c
int x = 42;
```

- Если инициализации не было, значение переменной **не определено.**
- Статические переменные инициализируются только один раз в начале работы программы.
- Автоматические переменные инициализируются каждый раз при входе в соответствующий блок
- Внешние переменные инициализируются в файле своего объявления.
- При использовании ключевого слова `const` переменная является константой и не может изменять свое значение.

### Литералы

- Символьные константы: `'a', L'B', '$', '\0x4f'`
- Целочисленные константы: `100, -34l, 1000U, 999llu`
- Константы с плавающей точкой: `11.123F, 4.56e-4f, 1.0`
- Шестнадцатеричные константы: `0x80, 0xac, 0x9ff`
- Восьмеричные константы: `012, 0777, 0666`
- Строковые константы: `"a", "Foo", "Hello, world!"`

---

## Операции

- Арифметические: `+ - * / %`
- Отношения: `< > >= <=`
- Сравнения: `== !=`
- Логические: `! && ||`

Результат логических операций - 0/1 типа `int`

В логических операциях вычисление аргументов происходит слева направо с "угадыванием" результата операции.  

#### Присваивание 

Побочные эффекты: изменение объекта, вызов функции

`lvalue = rvalue`
- `lvalue` - указатель на объект
- `rvalue` - выражение, генерируещее значение

```c
a = 42;
b = (a - 10) * 7;
a = b = c = d = 0;
```

#### Укороченное присваивание

`lvalue op= rvalue`
- `op` - двухместная операция

```c
foo += 15;
bar -= 10;
```

#### Инкремент и декремент

`++` и `--`

```c
x++; y--; // постфиксный
++x; --y; // префиксный
```

#### Последовательное вычисление

```c
a = (b = 5, b + 2)
```

### Точки следования (sequence points)

*Определение:* Точка следования - момент во время выполнения программы, в котором все побочные эффекты предыдущих вычеслений закончены, а новых - не начаты.

- первый операнд `&&`, `||`
- окончание *полного выражения*
- между вычислением фактических параметров и вызовом функции

Между двумя точками следования изменение значения переменной возможно **не более** одного раза.

---

## Ввод-вывод

```c
#include <stdio.h>
  
int main(void){
	int a, b;
	scanf("%d %d", &a, &b);
	
	int s = a + b;
	printf("%d\n", s);
	
	return 0;
}
```

### Спецификаторы ввода-вывода

- `%d, %ld, %lld` - `int, long, long long`
- `%u, %lu, %llu` - `unsigned, unsigned long, unsigned long long`
- `%f, %Lf` - печатает `double, long double`
- `%f, %lf, %Lf` - считывает `float, double, long double`
- `%c` - `char`

*Пример:*
```c
#include <stdio.h>
#include <math.h>

int main(void){
    int a, b, c, d;

    if (scanf("%d %d %d", &a, &b, &c) != 3){
        printf("Input three cooficients\n");
        return 1;
    }

    if (!a){
        printf("Not a quadratic polynom\n");
        return 1;
    }

    d = b*b - 4*a*c;
    if (d < 0){
        printf("No solutions\n");
    }else if (d == 0){
        double nb = -b;
        printf("x = %.4f\n", nb/(2*a));
    }else{
        double nb = -b;
        double sr = sqrt(d);

        printf(
	        "x1 = %.4f; x2 = %.4f\n", 
	        (nb+sr)/(2*a), (nb-sr)/(2*a)
        );
    }

    return 0;
}
```

## Приведение типов

Явное приведение: `(type) expr`:

```c
d = ((double) a+b) / 2
```

Неявное приведение (происходит, когда операнды двухместной операции имеют разные типы):

- Для `float, double` и `long double` - если один из операндов такого типа, то и другой преобразуется к нему:

```c
long double + long double -> long double + long double
int + double -> double + double 
float + short -> float + int -> float + float
```

- Если все значения операнда могут быть представлены в `int`, то операнд преобразуется к `int`, так же и для `unsigned int` (integer promotion):

```c
unsigned short(2) + char(1) -> int(4) + int(4)
unsigned short(4) + char(1) -> unsigned int(4) + unsigned int(4)
```

- Если оба операнда — соответственно знаковых или беззнаковых целых типов, то операнд более «узкого» типа преобразуется к операнду более «широкого» типа:

```c
int + long -> long + long
unsigned long long + unsigned -> unsigned long long + unsigned long long
```

## Поразрядные операции

- `&` - поразрядное "И"
- `|` - поразраядное "ИЛИ"
- `^` - поразрядноей исключающее "ИЛИ"
- `<<` - сдвиг влево
- `>>` - сдвиг вправо

Знаковое переполнение является неопределенным поведением.
Беззнаковое переполнение определенно - пропадают старшие биты.