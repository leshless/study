---
created: 2024-10-01T14:24
updated: 2024-10-02T13:50
---
## Операторы

- Условный оператор `if-else`:
```c
if (expr){
	stmt1
}else{
	stmt2
}
```

```c
if (x > 2) {
	if (y > z){
		y = z;
	}else {
		z = y;
	}
}
```

- Оператор выбора `switch-case`:
```c
switch (expr) {
	case const-expr1:
		stmt1;
	case const-expr2:
		stmt2;
	default:
		stmt3;
}
```
Оператор `break` - немедленный выход из `switch` блока.

- Операторы цикла
`for`:
```c
for (decl; expr1; expr2){
	stmt;
}
```
Тело цикла выполняется с `expr2` пока истинно `expr1`.

`while`:
```c
while(expr){
	stmt;
}
```
Тело цикла выполняется пока истинно `expr`.

`do-while`:
```c
do {
	stmt;
} while (expr)
```
Проверка условия `expr` выхода из цикла после выполнения тела `stmt`.

`for ( ; ; ) stmt;` - бесконечный цикл.

- `break` - выход из внутреннего цикла

- `continue` - переход на следующую итерацию цикла

- `goto` - переход по метке:
```c
goto label;
...
label:
```

---

## Тип данных `char`

Программа подсчета числа строк во входном потоке:
```c
#include <stdio.h>

int main (void){
	int c, nl = 0;
	while ((c = getchar()) != EOF)
		if (c == '\n')
			++nl;
	printf ("%d\n", nl);
	return 0;
}
```

Символьные данные представляются в некотором коде. (Чаще всего ASCII). Каждому символу сопоставляется его код - чило типа `char`.

![[Pasted image 20241002132932.png]]

К символьным данным применимы операции целочисленных типов.

Каждый символ-литерал заключается в одинарные кавычки ' '

Последовательность символов (строка) заключается в двойные кавычки " "

Специальные (управляющие) символы представляются последовательностями из двух символов:
- `\n` - начало новой строки
- `\t` - знак табуляции
- `\b` - возврат на один символ с затиранием

Преобразование сроки цифр в целое число:
```c
int atoi (char s[]){
	int i, n;
	n = 0;

	for (i = 0; s[i] >= '0' && s[i] <= '9'; i++){
		n = 10 * n + (s[i] - '0');
	}

	return n;
}
```

--- 

## Массивы

Массивы позволяют организовывать непрерывные последовательности элементов и обращаться к ним по индексу.

- Элементы массивов располагаются в памяти последовательно и индексируются с 0:
```c
int a[30]; // элементы - {a[0], a[1], ..., a[29]}
```

- Элементом массива может быть массив:
```c
int b[3][3] // элементы - {b[0][0], b[0][1], b[0][2], b[1][0], ..., b[2][2]}
```

- Контроль правильности индексов обращения не производится

### Инициализация массивов

```c
type name[dim1][dim2]...[dimN] = {values...};
```

- Можно не указывать размер массива — он будет вычислен по количеству элементов инициализатора:
```c
int sqrs[] = {1, 4, 9, 16, 25};
```

- Можно использовать модификаторы `const`, `static` и т.п.
- Можно использовать любое константное целочисленное выражение для определения размера.

---

## Строки

- Строка - это массив типа `char`
- Объявляя массив для хранения строки, необходимо предусмотреть место для символа `'\0'` (конец строки)
- Строковая константа записывается как "string constant". В конец строковой константы компилятор добавляет `'\0'`

Стандартная библиотека функций работы со строками `<string.h>` содержит такие функции, как:
```c
strcpy(s1, s2) // копирует s2 в s1
strc cat(s1, s2) // конкатенирует s1 и s2
strlen(s) // возвращает длину строки s
strcmp(s1, s2) // сравнивает s1 и s2 в лексикографическом порядке: возвращает значение выражения (s1 < s2)
strchr(s, ch) // возвращает указатель на первое вхождение символа ch в s
strstr(s1, s2) // возвращает указатель на первое вхождение подстроки s2 в s1
```

---

## Указатели

`&` - операция адресации
`*` - операция разыменовывания

```c
int a = 1;
int *p;

p = &a;
*p = 2;

printf("Значение переменной a = %d\n", *p); 
printf("Адрес переменной a = %p\n", p);
```

- `&foo` является константой
- Печать адреса - плейсхолдер `%p`
- Нулевой указатель - `NULL`